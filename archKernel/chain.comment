

// n: number of anchors
// sidi: id of read

for(int i = 0; i < n; i ++) {   //iterating n anchors
    int max_j = -1;
    int max_f = q_span;
    int n_skip = 0;
    int sidi = (a[i].y & MM_SEED_SEG_MASK) >> MM_SEED_SEG_SHIFT;

    while(st<i && ri > a[st].x + max_dist_x) ++st;
    
    for(int j = i - 1; j >= st; --j) {     // computing score of current seed.
        int sidj = (a[j].y & MM_SEED_SEG_MASK) >> MM_SEED_SEG_SHIFT;
        
        // branch misprediction
        if((sidi == sidj && dr == 0) || dq <= 0) continue;
        if((sidi == sidj && dq > max_dist_y) || dq > max_dist_x) continue;
        dd = dr > dq ? dr - dq : dq - dr;
        if(sidi == sidj && dd > bw) continue;
        if(n_segs > 1 && !is_cdna && sidi == sidj && dr > max_dist_y) continue;

        // sc can at least get 15 
        min = dq < dr ? dq : dr;
        sc = min > q_span ? q_span : dq < dr ? dq : dr;
        
        sc = computeScore();
        sc += f[j];  

        if(sc > max_f) {
            max_f = sc, max_j = j;
            if(n_skip > 0) --n_skip;
        }else if(t[j] == i) {
            if(++n_skip > max_skip)
                break;
        }
        if(p[j] >= 0) t[p[j]] = i;   
    }

    f[i] = max_f, p[i] = max_j;
    v[i] = max_j >= 0 && v[max_j] > max_f ? v[max_j] : max_f;

}

memset(t, 0, n*4);
for(int i = 0; i < n; i ++) {
    if(p[i] >= 0) t[p[i]] = 1;     // find ends of chains: if 3 is not in p, then 3 is a end.
}

// if t[i] = 0, then i is a end.
for(int i = n_u = 0; i < n; i ++) {
    if(t[i] == 0 && v[i] >= min_sc) ++n_u;   // how many chains(>min_sc)
}

// to collect high quality chain
u = (uint64_t*)kmalloc(km, n_u * 8);   
for(i = n_u = 0; i < n; i ++) {
    // start from end of a chain
    if(t[i] == 0 && v[i] >= min_sc) {  // min_sc = 40; minimium score by default
        j = i;
        //while(j >= 0 && f[j] < v[j]) j = p[j];  
        u[n_u++] = (uint64_t)f[j] << 32 | j;
    }
}
radix_sort_64(u, u + n_u);
for(i = 0; i < n_u>>1; i ++) {  //reverse, the highest scoring chain is the first
    uint64_t t = u[i];
    u[i] = u[n_u-i-1], 
    u[n_u-i-1] = t;
}


// backtrack   to record each element of chain
memset(t, 0, n*4);
for(int i = n_v = k = 0; i < n_u; i ++){    // starting from the highest score.
    int32_t n_v0 = n_v, k0 = k;
    j = (int32_t)u[i];  // start from end of a chain
    do{
        v[n_v++] = j;
        t[j] = 1;
        j = p[j];
    }while(j >= 0 && t[j] == 0);   // j = -1means end.
    if(j < 0) {  // j = -1
        if(n_v - n_v0 >= min_cnt) u[k++] = u[i]>>32<<32 | (n_v - n_v0);
    }else if((int32_t)(u[i]>>32) - f[j] >= min_sc) {   // TODO:special case: part of chain 
        if(n_v - n_v0 >= min_cnt) u[k++] = ((u[i]>>32)-f[j]) << 32 | (n_v - n_v0)
    }

    if(k0 == k) n_v = n_v0;
}

